<!DOCTYPE html>
<html>
<head>
    <title>Pro Security Camera</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .camera-container {
            width: 600px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
        }

        #camera-view {
            width: 100%;
            height: 300px;
            background-color: #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative; /* For overlay */
        }

        #camera-view video {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
        }

        #motion-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make it transparent to clicks */
        }

        .controls {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            border: none;
            background-color: #4CAF50;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #3e8e41;
        }

        #status {
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
        }

        /* Styles for alert */
        .alert {
            background-color: #fdd;
            color: #a00;
            border: 1px solid #f00;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: none; /* Initially hidden */
        }

        /* CSS for circle on/off */
        .circle-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #ccc;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s ease;
            margin: 5px;
        }

        .circle-button.on {
            background-color: #4CAF50;
        }

        .circle-button:hover {
            opacity: 0.8;
        }

    </style>
</head>
<body>

<div class="camera-container">
    <h1>Pro Security Camera</h1>

    <div id="camera-view">
        <video id="camera-video" autoplay playsinline muted></video>
        <canvas id="motion-overlay"></canvas>
    </div>

    <div id="status">Status: Ready</div>

    <div class="controls">
        <button id="start-button">Start Monitoring</button>
        <button id="stop-button" disabled>Stop Monitoring</button>
        <button id="detection-toggle" class="circle-button">
           <span id="detection-icon">âšª</span> <!-- White Circle (off) -->
        </button>
    </div>

    <div id="alert-message" class="alert">
        Motion Detected! Intruder Alert!
    </div>

    <audio id="alarm-sound" src="alarm.mp3" preload="auto"></audio>

    <div id="ip-address"></div>
</div>

<script>
    const cameraVideo = document.getElementById('camera-video');
    const motionOverlay = document.getElementById('motion-overlay');
    const statusDisplay = document.getElementById('status');
    const startButton = document.getElementById('start-button');
    const stopButton = document.getElementById('stop-button');
    const alertMessage = document.getElementById('alert-message');
    const alarmSound = document.getElementById('alarm-sound');
    const motionOverlayCtx = motionOverlay.getContext('2d');
    const detectionToggle = document.getElementById('detection-toggle');
    const detectionIcon = document.getElementById('detection-icon');  // Icon for toggle
    const ipAddressDisplay = document.getElementById('ip-address');

    let monitoringActive = false;
    let motionDetectionEnabled = true; // Initially enabled
    let lastFrameData = null;
    let motionThreshold = 30;
    let detectionInterval = 100;
    let stream = null;
    let motionBoxColor = 'rgba(255, 0, 0, 0.5)';

   // Function to get IP address (simulated for this single-file example)
    function getIPAddress() {
        // In a real app, you would use a service to get the public IP address.
        // This is a SIMULATION for this example.  It will return a dummy IP.
        const dummyIP = "192.168.1.100"; // Replace with your actual local IP if known
        ipAddressDisplay.textContent = "Camera IP: " + dummyIP;
        return dummyIP;
    }


    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            cameraVideo.srcObject = stream;
            cameraVideo.onloadedmetadata = () => {
                motionOverlay.width = cameraVideo.videoWidth;
                motionOverlay.height = cameraVideo.videoHeight;
                statusDisplay.textContent = "Status: Camera Ready";
                getIPAddress(); // Get IP address after camera is ready
            };
        } catch (error) {
            console.error("Error accessing camera:", error);
            statusDisplay.textContent = "Status: Camera Error - " + error.message;
            alert("Error accessing camera. Please make sure you have granted permission.");
        }
    }

    function startMonitoring() {
        if (!stream) {
            alert("Camera not initialized. Please try again.");
            return;
        }

        monitoringActive = true;
        startButton.disabled = true;
        stopButton.disabled = false;
        statusDisplay.textContent = "Status: Monitoring...";
        lastFrameData = captureFrame(cameraVideo);
        motionDetectionInterval = setInterval(detectMotion, detectionInterval);
    }

    function stopMonitoring() {
        monitoringActive = false;
        startButton.disabled = false;
        stopButton.disabled = true;
        statusDisplay.textContent = "Status: Ready";
        alertMessage.style.display = 'none';
        clearInterval(motionDetectionInterval);
        alarmSound.pause();
        alarmSound.currentTime = 0;
        motionOverlayCtx.clearRect(0, 0, motionOverlay.width, motionOverlay.height);
    }

    function captureFrame(video) {
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        return getImageData(canvas);
    }

    function getImageData(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const grayscaleData = [];

        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
            grayscaleData.push(avg);
        }
        return grayscaleData;
    }

    function detectMotion() {
        if (!monitoringActive || !motionDetectionEnabled) return; // Respect toggle state

        const currentFrameData = captureFrame(cameraVideo);

        if (lastFrameData === null) {
            lastFrameData = currentFrameData;
            return;
        }

        let motionDetected = false;
        let motionAreas = [];

        for (let i = 0; i < currentFrameData.length; i++) {
            const diff = Math.abs(currentFrameData[i] - lastFrameData[i]);
            if (diff > motionThreshold) {
                motionDetected = true;
                const x = (i % (motionOverlay.width));
                const y = Math.floor(i / (motionOverlay.width));
                motionAreas.push({ x: x, y: y });
            }
        }

        if (motionDetected) {
            console.log("Motion Detected!");
            showAlert();
            drawMotionBoxes(motionAreas);
        } else {
            motionOverlayCtx.clearRect(0, 0, motionOverlay.width, motionOverlay.height);
        }

        lastFrameData = currentFrameData;
    }

    function drawMotionBoxes(motionAreas) {
        motionOverlayCtx.clearRect(0, 0, motionOverlay.width, motionOverlay.height);
        motionOverlayCtx.fillStyle = motionBoxColor;

        let groupedMotionAreas = groupMotionAreas(motionAreas, 10);

        groupedMotionAreas.forEach(group => {
            let minX = group[0].x;
            let minY = group[0].y;
            let maxX = group[0].x;
            let maxY = group[0].y;

            group.forEach(area => {
                minX = Math.min(minX, area.x);
                minY = Math.min(minY, area.y);
                maxX = Math.max(maxX, area.x);
                maxY = Math.max(maxY, area.y);
            });

            motionOverlayCtx.fillRect(minX, minY, maxX - minX, maxY - minY);
        });
    }

    function groupMotionAreas(motionAreas, distanceThreshold) {
        let groups = [];
        let assigned = new Array(motionAreas.length).fill(false);

        for (let i = 0; i < motionAreas.length; i++) {
            if (assigned[i]) continue;

            let newGroup = [motionAreas[i]];
            assigned[i] = true;

            for (let j = i + 1; j < motionAreas.length; j++) {
                if (!assigned[j]) {
                    let distance = Math.sqrt(
                        Math.pow(motionAreas[i].x - motionAreas[j].x, 2) +
                        Math.pow(motionAreas[i].y - motionAreas[j].y, 2)
                    );

                    if (distance <= distanceThreshold) {
                        newGroup.push(motionAreas[j]);
                        assigned[j] = true;
                    }
                }
            }

            groups.push(newGroup);
        }

        return groups;
    }

    function showAlert() {
        alertMessage.style.display = 'block';
        alarmSound.play();
    }

    // Motion detection toggle functionality
    detectionToggle.addEventListener('click', () => {
        motionDetectionEnabled = !motionDetectionEnabled;
        if (motionDetectionEnabled) {
            detectionToggle.classList.add('on');
            detectionToggle.classList.remove('off');
            detectionIcon.innerHTML = 'âš«'; // Black Circle (on)
        } else {
            detectionToggle.classList.remove('on');
            detectionToggle.classList.add('off');
            detectionIcon.innerHTML = 'âšª'; // White Circle (off)
            motionOverlayCtx.clearRect(0, 0, motionOverlay.width, motionOverlay.height); // Clear overlay
        }
    });

    startButton.addEventListener('click', startMonitoring);
    stopButton.addEventListener('click', stopMonitoring);

    startCamera();
</script>

</body>
</html>
